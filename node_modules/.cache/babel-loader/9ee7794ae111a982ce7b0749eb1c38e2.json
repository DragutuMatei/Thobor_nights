{"ast":null,"code":"/**\n * Created by alykoshin on 8/12/14.\n */\n'use strict';\n\nconst _ = require('lodash');\n\nconst path = require('path');\n\nconst nodemailer = require('nodemailer');\n/**\n * sendOptions - options for nodemailer\n *\n * @typedef {Object} sendOptions\n * @property {string} options.user\n * @property {string} options.pass\n * @property {(string || string[])} options.files\n * @property {string} options.from\n * @property {string} options.to\n * @property {string} options.replyTo\n * @property {string} options.text\n * @property {string} options.html\n * @property {string} options.attachments - array of `nodemailer`s compatible attachments definitions\n */\n\n/**\n * @callback sendCallback\n * @param {Object} error\n * @param {string} result\n * @param {Object} fullResult\n */\n\n/**\n * @constructor\n * @param {sendOptions} options  - options for underlying nodemailer\n * @type {Function}\n */\n\n\nconst GMailSend = function (options) {\n  const self = this;\n  /** @member {string} */\n\n  self.options = options;\n  /** helper to build 'Some Name <some.name@domain.com>' **/\n\n  function prepareAddress(name, address) {\n    return name + ' ' + '<' + address + '>';\n  }\n\n  function _send(options, callback) {\n    const handleSuccess = info => {\n      if (callback) {\n        callback(null, info.response, info); //} else { //\n        //  const result = {\n        //    result: info && info.response,\n        //    full:   info,\n        //  };\n        //  resolve(result);\n      }\n    };\n\n    const handleError = error => {\n      if (typeof error === 'string') error = new Error(error);\n\n      if (callback) {\n        callback(error, error.message, undefined); //} else {\n        //  reject(error);\n      }\n    };\n\n    options.from = options.from || options.user; //options.replyTo = options.replyTo || options.user;\n    // Configure email transport\n\n    const TRANSPORT = {\n      service: 'Gmail',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    };\n    const smtpTransport = nodemailer.createTransport(TRANSPORT); // Preparing nodemailer options (and attachments)\n    // File attachments\n\n    options.files = options.files || [];\n    if (!Array.isArray(options.files)) options.files = [options.files]; //if (typeof options.files === 'string') { options.files = [options.files]; }\n\n    options.attachments = options.attachments || [];\n\n    for (let i = 0; i < options.files.length; i++) {\n      let file = options.files[i]; // if string is passed, convert it to `nodemailer` attachment object\n\n      if (typeof file === 'string') {\n        file = {\n          path: file //filename: path.basename( file ),\n          //cid:      path.basename( file ),\n\n        };\n      }\n\n      if (!file.path) {\n        //const msg = 'file/filepath to attach must be set';\n        //if (callback) callback(new Error(msg), msg, undefined);\n        //return reject()\n        return handleError('file/filepath to attach must be set');\n      }\n\n      if (typeof file.filename === 'undefined') file.filename = path.basename(file.path);\n      if (typeof file.cid === 'undefined') file.cid = file.filename; // we do not validate if options.files[i] is really object and has valid properties\n      // add to options.attachments used by `nodemailer`\n\n      options.attachments.push(file);\n    }\n\n    delete options.files; // remove files property as incompatible with options of underlying `nodemailer`\n    // from\n\n    options.from = prepareAddress(options.from, options.from); // adjust to nodemailer format\n    // to\n\n    if (typeof options.to === 'string') {\n      options.to = prepareAddress(options.to, options.to); // adjust to nodemailer format\n    } else if (Array.isArray(options.to)) {\n      let to = options.to.map(addr => prepareAddress(addr, addr));\n      options.to = to.join(',');\n    } // Sending email\n    //console.log('gmail-send: send(): mailOptions: ', options);\n\n\n    return smtpTransport.sendMail(options, function (error, info) {\n      if (error) {\n        //console.log('gmail-send: send(): Error sending message:', error);\n        //if (callback) callback(error);\n        //return reject(error);\n        return handleError(error);\n      } else {\n        //console.log(\"gmail-send: send(): Message sent: \" + info.response);\n        //if (callback) callback(null, info.response, info);\n        //return resolve(info.response, info);\n        return handleSuccess(info);\n      }\n    }); // smtpTransport.sendMail()\n  } // function _send()\n\n  /**\n   * Send email\n   *\n   * You may use almost any option available in Nodemailer,\n   * but if you need fine tuning I'd recommend to consider using Nodemailer directly.\n   *\n   * @param {sendOptions}  [options]  - options for underlying nodemailer\n   * @param {sendCallback} [callback]\n   * @return Promise({{ result: string, full: object }})\n   */\n\n\n  self.send = function (options, callback) {\n    if (arguments.length === 1) if (typeof options === 'function') {\n      // only callback function is provided\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n    options = _.extend({}, self.options, options);\n\n    if (!options.user || !options.pass) {\n      throw new Error('options.user and options.pass are mandatory.');\n    }\n\n    if (callback) return _send(options, callback);else return new Promise((resolve, reject) => _send(options, (error, result, full) => error ? reject(error) : resolve({\n      result,\n      full\n    })) // _send()\n    ); // return new Promise()\n  }; // self.send = function()\n\n\n  return self;\n}; //\n\n/**\n * Exporting function to send email\n *\n * @param {sendOptions} options  - options for new GMailSend()\n * @returns {function}\n */\n\n\nmodule.exports = function (options) {\n  return new GMailSend(options).send;\n};","map":{"version":3,"sources":["D:/xampp/htdocs/React/Thobo_nights/Thobor_nights/node_modules/gmail-send/index.js"],"names":["_","require","path","nodemailer","GMailSend","options","self","prepareAddress","name","address","_send","callback","handleSuccess","info","response","handleError","error","Error","message","undefined","from","user","TRANSPORT","service","auth","pass","smtpTransport","createTransport","files","Array","isArray","attachments","i","length","file","filename","basename","cid","push","to","map","addr","join","sendMail","send","arguments","extend","Promise","resolve","reject","result","full","module","exports"],"mappings":"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","sourcesContent":["/**\n * Created by alykoshin on 8/12/14.\n */\n\n'use strict';\n\nconst _ = require('lodash');\nconst path = require('path');\nconst nodemailer = require('nodemailer');\n\n/**\n * sendOptions - options for nodemailer\n *\n * @typedef {Object} sendOptions\n * @property {string} options.user\n * @property {string} options.pass\n * @property {(string || string[])} options.files\n * @property {string} options.from\n * @property {string} options.to\n * @property {string} options.replyTo\n * @property {string} options.text\n * @property {string} options.html\n * @property {string} options.attachments - array of `nodemailer`s compatible attachments definitions\n */\n/**\n * @callback sendCallback\n * @param {Object} error\n * @param {string} result\n * @param {Object} fullResult\n */\n/**\n * @constructor\n * @param {sendOptions} options  - options for underlying nodemailer\n * @type {Function}\n */\nconst GMailSend = function(options) {\n  const self = this;\n\n  /** @member {string} */\n  self.options = options;\n\n  /** helper to build 'Some Name <some.name@domain.com>' **/\n  function prepareAddress(name, address) {\n    return name + ' ' + '<' + address + '>';\n  }\n\n\n  function _send(options, callback) {\n\n    const handleSuccess = (info) => {\n      if (callback) {\n        callback(null, info.response, info);\n        //} else { //\n        //  const result = {\n        //    result: info && info.response,\n        //    full:   info,\n        //  };\n        //  resolve(result);\n      }\n    };\n\n    const handleError = (error) => {\n      if (typeof error === 'string') error = new Error(error);\n      if (callback) {\n        callback(error, error.message, undefined);\n        //} else {\n        //  reject(error);\n      }\n    };\n\n    options.from = options.from || options.user;\n    //options.replyTo = options.replyTo || options.user;\n\n    // Configure email transport\n\n    const TRANSPORT = {\n      service: 'Gmail', auth: { user: options.user, pass: options.pass }\n    };\n\n    const smtpTransport = nodemailer.createTransport(TRANSPORT);\n\n    // Preparing nodemailer options (and attachments)\n\n    // File attachments\n\n    options.files = options.files || [];\n    if (!Array.isArray(options.files)) options.files = [ options.files ];\n    //if (typeof options.files === 'string') { options.files = [options.files]; }\n\n    options.attachments = options.attachments || [];\n    for (let i = 0; i < options.files.length; i++) {\n      let file = options.files[ i ];\n      // if string is passed, convert it to `nodemailer` attachment object\n      if (typeof file === 'string') {\n        file = {\n          path: file,\n          //filename: path.basename( file ),\n          //cid:      path.basename( file ),\n        };\n      }\n      if (!file.path) {\n        //const msg = 'file/filepath to attach must be set';\n        //if (callback) callback(new Error(msg), msg, undefined);\n        //return reject()\n        return handleError('file/filepath to attach must be set');\n      }\n      if (typeof file.filename === 'undefined') file.filename = path.basename(file.path);\n      if (typeof file.cid      === 'undefined') file.cid      = file.filename;\n      // we do not validate if options.files[i] is really object and has valid properties\n      // add to options.attachments used by `nodemailer`\n      options.attachments.push(file);\n    }\n    delete options.files; // remove files property as incompatible with options of underlying `nodemailer`\n\n    // from\n\n    options.from = prepareAddress(options.from, options.from); // adjust to nodemailer format\n\n    // to\n\n    if (typeof options.to === 'string') {\n      options.to = prepareAddress(options.to, options.to);   // adjust to nodemailer format\n\n    } else if (Array.isArray(options.to)) {\n      let to     = options.to.map((addr) => prepareAddress(addr, addr));\n      options.to = to.join(',');\n    }\n\n    // Sending email\n\n    //console.log('gmail-send: send(): mailOptions: ', options);\n    return smtpTransport.sendMail(options, function (error, info) {\n      if (error) {\n        //console.log('gmail-send: send(): Error sending message:', error);\n        //if (callback) callback(error);\n        //return reject(error);\n        return handleError(error);\n\n      } else {\n        //console.log(\"gmail-send: send(): Message sent: \" + info.response);\n        //if (callback) callback(null, info.response, info);\n        //return resolve(info.response, info);\n        return handleSuccess(info);\n      }\n    }); // smtpTransport.sendMail()\n\n  } // function _send()\n\n\n  /**\n   * Send email\n   *\n   * You may use almost any option available in Nodemailer,\n   * but if you need fine tuning I'd recommend to consider using Nodemailer directly.\n   *\n   * @param {sendOptions}  [options]  - options for underlying nodemailer\n   * @param {sendCallback} [callback]\n   * @return Promise({{ result: string, full: object }})\n   */\n  self.send = function(options, callback) {\n    if (arguments.length === 1)\n      if (typeof options === 'function') { // only callback function is provided\n        callback = options;\n        options = {};\n      }\n\n    options = options || {};\n    options = _.extend({}, self.options, options);\n    if (!options.user || !options.pass) { throw new Error('options.user and options.pass are mandatory.'); }\n\n\n    if (callback) return _send(\n      options,\n      callback,\n    );\n    else return new Promise((resolve, reject) =>\n      _send(\n        options,\n        (error, result, full) => error\n                                 ? reject(error)\n                                 : resolve({ result, full })\n      ) // _send()\n    ); // return new Promise()\n\n  }; // self.send = function()\n\n  return self;\n};\n\n//\n\n/**\n * Exporting function to send email\n *\n * @param {sendOptions} options  - options for new GMailSend()\n * @returns {function}\n */\nmodule.exports = function(options) {\n  return new GMailSend(options).send;\n};\n"]},"metadata":{},"sourceType":"script"}